% 20 вариант
clear;
close all;

% I часть

% Выборка в отчёт
P = [4.3 2.3 3.6 4.8 2.8 -3.3; 2.2 -4.4 4.3 3.5 0.1 -1.1]; % Входы
T = [1 0 1 1 1 0]; % Выходы

% Создание сети
net = newp([-5 5; -5 5], [0 1]); % new perceptron на плоскости -5 5 по обеим осям
display(net); % Вывод структуры сети
view(net); % Отображение диаграммы сети

% Обучение
net.inputWeights{1, 1}.initFcn = 'rands'; % Инициализируем веса и смещения случайными значениями
net.biases{1}.initFcn = 'rands';

net = init(net); % Инициализация сети с весами и смещениями

IW = net.IW{1, 1}; 
b = net.b{1};

plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

M1 = mae(T - net(P)); % Вычисление средней абсолютной ошибки

% Обучаем с помощью алгоритма Розенблатта
passes = 50;
P_length = length(P); % 6 потому что шесть точек
for j = 1:passes
    for i = 1:P_length
        p = P(:,i); % Выбираем точку из вектора входа
        t = T(:,i); % Выбираем точку из целевого вектора
        IW = net.IW{1, 1};
        b = net.b{1};
        A = sim(net, p); % Получаем выход A_i, запуская p в сети net
        e = t - A; % Вычисляем ошибку
        if (~mae(e)) % Если ошибка нулевая, то продолжаем
            continue;
        else % Иначе по формуле Розенблатта вычисляем значения весов
            net.IW{1, 1} = IW + e*transpose(p);
            et.b{1} = b + e;
        end
    end
end

passes = 50;
P_length = length(P); % 6 потому что шесть точек
for j = 1:passes
    for i = 1:P_length
        p = P(:,i); % Выбираем точку из вектора входа
        t = T(:,i); % Выбираем точку из целевого вектора
        IW = net.IW{1, 1};
        b = net.b{1};
        A = sim(net, p); % Получаем выход A_i, запуская p в сети net
        e = t - A; % Вычисляем ошибку
        if (~mae(e)) % Если ошибка нулевая, то продолжаем
            continue;
        else % Иначе по формуле Розенблатта вычисляем значения весов
            net.IW{1, 1} = IW + e*transpose(p);
            et.b{1} = b + e;
        end
    end
end

M2 = mae(T - net(P)); % Повторно вычисляем среднюю абсолютную ошибку после обучения

% Рисуем
figure;
plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

% Встроенное обучение
net.trainParam.epochs=50;
net = train(net, P, T);

% Для обобщения
P(:, 7) = [5*rands(1), 5*rands(1)];
P(:, 8) = [5*rands(1), 5*rands(1)];
P(:, 9) = [5*rands(1), 5*rands(1)];

T = sim(net, P);

% Рисуем
first_part = figure;
plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

uiwait(first_part);

clear;
close all;

% II часть

% Линейно-неразделимые классы

P = [4.3 2.3 3.6 4.8 -2.1 -3.3; 2.2 -4.4 4.3 3.5 -3 -1.1]; % Входы
T = [1 0 1 1 1 0]; % Выходы

% Создание сети
net = newp([-5 5; -5 5], [0 1]); % new perceptron на плоскости -5 5 по обеим осям
display(net); % Вывод структуры сети
view(net); % Отображение диаграммы сети

% Обучение
net.inputWeights{1, 1}.initFcn = 'rands'; % Инициализируем веса и смещения случайными значениями
net.biases{1}.initFcn = 'rands';

net = init(net); % Инициализация сети с весами и смещениями

plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

% Встроенное обучение
net.trainParam.epochs=50;
net = train(net, P, T);

% Рисуем
second_part = figure;
plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

uiwait(second_part);

clear;
close all;

% III часть

P = [-4.4 0.2 1.5 -2.1 -4.9 -3.4 -1.3 -0.2; -1.1 -0.9 1.2 -0.7 4.8 -4 -3.1 -1.7]; % Входы
T = [1 0 0 0 0 1 0 0; 0 0 1 0 1 0 0 0]; % Выходы

% Создание сети
net = newp([-5 5; -5 5], [0 0 1 1; 0 1 0 1]); % new perceptron на плоскости -5 5 по обеим осям
display(net); % Вывод структуры сети
view(net); % Отображение диаграммы сети

% Обучение
net.inputWeights{1, 1}.initFcn = 'rands'; % Инициализируем веса и смещения случайными значениями
net.biases{1}.initFcn = 'rands';

net = init(net); % Инициализация сети с весами и смещениями

% Рисуем
figure;
plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

% Встроенное обучение
net.trainParam.epochs=50;
net = train(net, P, T);

% Встроенное обучение
net.trainParam.epochs=50;
net = train(net, P, T);

% Для обобщения
P(:, 9) = [5*rands(1), 5*rands(1)];
P(:, 10) = [5*rands(1), 5*rands(1)];
P(:, 11) = [5*rands(1), 5*rands(1)];
P(:, 12) = [5*rands(1), 5*rands(1)];
P(:, 13) = [5*rands(1), 5*rands(1)];

T = sim(net, P);

% Рисуем
figure;
plotpv(P, T); % Отмечаем точки входа и цели на плоскости
grid; % Добавляем сетку
plotpc(net.IW{1}, net.b{1}); % Рисуем разграничительную линию

